%%\chapter{Processes}
% \label{chapter-scenario-processes}

\section{Simple Process Sequence}

\textbf{Created by:} Jim Logan \\
\textbf{Modified by:} Jim Logan \\

\subsection*{Scenario Objective}
% Instruction box
This scenario demonstrates how to represent a sequence of time-stamped events using the \textbf{BFO/IOF ontology}. Several use cases are given, where each subsequent use case augments the previous one, culminating in a use case that demonstrates how to determine the type of an overall process automatically from a sequence of sub-processes.

\textit{ 
Note: I'm unsure what to say about the purpose of doing this!
}

\subsection*{General Pattern Description}

This pattern creates instances of \cname{bfo}{process}, each of which
\opname{core}{occupiesTemporalRegion}
one \\
\cname{bfo}{temporalInterval}
with single start and end instances of
\cname{bfo}{TemporalInstant}
that each \\
\opname{core}{hasValueExpressionAtAllTimes} some
\cname{core}{TemporalInstantValueExpression}, according to the earlier pattern in
\ref{sec-clock-calendar}.

\textit{
TBD: Provide a figure containing the pattern independent of the use case (e.g., just measurements in general as opposed to measuring a particular thing such as pH or length).
}
\noindent \textit{This diagram is generally a simple class-relation diagram. Please see examples of class-relation diagram here.}

\textit{ 
Describe the general pattern, including any background why such types and relations are used. Also mention any alternative or shortcuts. Please provide a background of the types and relations in the context of IOF (please prefer logical arguments to didactic arguments).
}


\subsection*{Use Case: Simple Process Sequence}
This first use case is the simplest. It uses the example data, shown below, to create directly-\\corresponding instances in the IOF theory of what must have existed in the world to justify the data.

 \textit{ 
Describe a concrete use case for the pattern. (Multiple use cases can be described for one pattern. If multiple, please use distinct use case titles and repeat all subsubsections for each use case.)
  }

\newcommand{\ti}{\cname{bfo}{TemporalInstant }}

\subsubsection*{Use-Case Pattern Description}
This use case follows the pattern in \ref{sec-clock-calendar}.
Each timestamp in a row that is marked "Start" creates several instances at once and then wires them together as follows:
a \cname{bfo}{Process} that \opname{core}{occupiesTemporalRegion} a \ti that \opname{bfo}{hasFirstInstant} a \cname{bfo}{TemporalInstant} that \cname{iof}{hasValueExpressionAtAllTimes} a \cname{time}{DateTimeDescription}.

Each timestamp in a row that is marked "Stop" augments what was already created for a "Start" row with several more instances and then wires them together as follows:
the already-created \cname{bfo}{TemporalRegion} \opname{bfo}{hasLastInstant} a \cname{bfo}{TemporalInstant} that \cname{iof}{hasValueExpressionAtAllTimes} a \cname{time}{DateTimeDescription}.

 \textit{ 
Provide a diagram which matches the use-case pattern description. \\
\noindent \textit{This diagram is generally an object diagram. Please see examples of object diagram here.}
  }

 \textit{ 
Describe how the general pattern is applied to the use case. It is important to highlight within the description how the use-case-specific concepts align with the general pattern (e.g., SubClassOf Class for general pattern).
  }

\subsubsection*{Use-Case Example Data}
The following table shows CSV data resulting from a fictitious machine that makes drip coffee. Each row contains the date and time at which a type of event started or stopped.
    
\csvautotabular{scenarios/simple-process-sequence/data/EventLog.csv} 

\subsubsection*{Data Mapping}
 \textit{ 
Describe how the data was mapped to RDF. Provide an INSERT DATA/ INSERT SPARQL for mapping. Use INSERT only when the use case example data needs further manipulation. \\
For INSERT DATA SPARQL, use only 2/3 records/transactions with named class and individuals. \\
For INSERT SPARQL, declare column names by `\{ \}' to the variable.  
For INSERT query, 
For both, do not use blank nodes.    
  }

\subsubsection*{Data Validation}
 \textit{ 
Data validation can be performed in two ways: accessing interesting facts using SPARQL or validating whether the entire data conforms to the ontology using SHACL. It is preferable to provide both. \\
Provide the SPARQL query in the code block along with the result of the query. \\
  }

\subsection*{Use Case: Typed Process Sequence}
 \textit{ 
Describe a concrete use case for the pattern. (Multiple use cases can be described for one pattern. If multiple, please use distinct use case titles and repeat all subsubsections for each use case.)
  }

\subsubsection*{Use-Case Pattern Description}
 \textit{ 
Provide a diagram which matches the use-case pattern description. \\
\noindent \textit{This diagram is generally an object diagram. Please see examples of object diagram here.}
  }

 \textit{ 
Describe how the general pattern is applied to the use case. It is important to highlight within the description how the use-case-specific concepts align with the general pattern (e.g., SubClassOf Class for general pattern).
  }

\subsubsection*{Use-Case Example Data}
The following table shows CSV data resulting from a fictitious machine that makes drip coffee. Each row contains the date and time at which a type of event started or stopped.

\begin{table}[]
    \centering
    \csvautotabular{scenarios/simple-process-sequence/data/EventLog.csv}
    \caption{Caption}
    \label{tab:my_label}
\end{table}    


\subsubsection*{Data Mapping}
 \textit{ 
Describe how the data was mapped to RDF. Provide an INSERT DATA/ INSERT SPARQL for mapping. Use INSERT only when the use case example data needs further manipulation. \\
For INSERT DATA SPARQL, use only 2/3 records/transactions with named class and individuals. \\
For INSERT SPARQL, declare column names by `\{ \}' to the variable.  
For INSERT query, 
For both, do not use blank nodes.    
  }

\subsubsection*{Data Validation}
 \textit{ 
Data validation can be performed in two ways: accessing interesting facts using SPARQL or validating whether the entire data conforms to the ontology using SHACL. It is preferable to provide both. \\
Provide the SPARQL query in the code block along with the result of the query. \\
  }